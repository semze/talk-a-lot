<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Talk-a-lot — Live Chat + Voice</title>
  <style>
    :root{
      --bg:#f6f8fa; --card:#fff; --muted:#6b7280; --accent:#0366d6; --me:#e6f0ff;
      --glass: rgba(255,255,255,0.8);
    }
    *{box-sizing:border-box}
    body{font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:0; padding:1.25rem; background:var(--bg); color:#0f172a}
    .wrap{max-width:1100px; margin:0 auto; display:grid; gap:1rem; grid-template-columns: 1fr 360px;}
    @media (max-width:980px){ .wrap{ grid-template-columns:1fr } }
    .panel{background:var(--card); padding:1rem; border-radius:12px; box-shadow:0 8px 30px rgba(2,6,23,0.06); }
    header{display:flex;align-items:center;justify-content:space-between;gap:1rem;margin-bottom:0.5rem}
    h1{font-size:1.125rem;margin:0}
    .status{color:var(--muted); font-size:0.9rem}
    /* Chat column */
    .chat{display:flex;flex-direction:column; height:75vh; gap:0.75rem}
    .messages{flex:1; overflow:auto; padding:0.5rem; border-radius:8px; background:linear-gradient(180deg,#ffffff, #fbfdff); border:1px solid #eef2f7}
    .msg-row{display:flex; gap:0.6rem; margin-bottom:0.55rem}
    .avatar{width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600}
    .bubble{padding:0.5rem 0.7rem;border-radius:10px;max-width:78%; word-wrap:break-word;box-shadow:0 1px 0 rgba(0,0,0,0.02)}
    .meta{font-size:0.78rem;color:var(--muted); margin-bottom:0.25rem}
    .me { margin-left:auto; display:flex; gap:0.6rem; align-items:flex-end }
    .me .bubble{background:var(--me)}
    .other .bubble{background:#f7f8fb}
    .inputRow{display:flex; gap:0.5rem; align-items:center}
    textarea{flex:1; min-height:54px; padding:0.6rem; border-radius:8px; border:1px solid #e6eef6; resize:vertical; font-size:0.95rem}
    input[type="text"]{padding:0.5rem;border-radius:8px;border:1px solid #e6eef6}
    button{padding:0.55rem .8rem;border-radius:8px;border:1px solid #d6dbe6;background:#fff;cursor:pointer}
    button.primary{background:var(--accent); color:#fff; border-color:transparent}
    .small{font-size:0.88rem;color:var(--muted)}
    /* Right column (controls/calls) */
    .side-section{display:flex;flex-direction:column;gap:0.75rem}
    .call-card{display:flex;flex-direction:column;gap:0.6rem}
    .call-actions{display:flex;gap:0.5rem;align-items:center}
    .toggle{display:inline-flex;align-items:center;gap:0.5rem;padding:.4rem .6rem;border-radius:8px;border:1px solid #e6eef6;background:var(--glass)}
    audio{width:100%}
    .hint{font-size:0.82rem;color:var(--muted)}
    select{padding:.45rem;border-radius:8px;border:1px solid #e6eef6;background:#fff}
    .device-row{display:flex;gap:.5rem;align-items:center}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Chat column -->
    <div class="panel">
      <header>
        <div>
          <h1>Talk-a-lot — Live Chat</h1>
          <div class="status" id="status">Initializing…</div>
        </div>
        <div style="text-align:right">
          <div class="small">Signed in as <strong id="displayNameLabel">—</strong></div>
          <div class="small" id="uidLabel"></div>
        </div>
      </header>

      <div class="chat">
        <div class="messages" id="messages" aria-live="polite"></div>

        <div style="display:flex;gap:.5rem;align-items:center;">
          <input id="displayName" type="text" placeholder="Display name (optional)" style="width:240px" />
          <div style="flex:1"></div>
          <button id="signOut" style="display:none">Sign out</button>
          <button id="anonSignIn">Sign in anonymously</button>
        </div>

        <div class="inputRow">
          <textarea id="messageInput" placeholder="Type a message (press Enter to send)"></textarea>
          <button id="sendBtn" class="primary">Send</button>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
          <div class="small">Messages are public in collection <code>chat_messages</code></div>
          <div class="small" id="typingIndicator"></div>
        </div>
      </div>
    </div>

    <!-- Side column: calls, presence, controls -->
    <div class="panel side-section">
      <div>
        <div class="small">Presence</div>
        <div style="display:flex;gap:.6rem;align-items:center;margin-top:.4rem">
          <div style="width:12px;height:12px;border-radius:50%;background:#10b981"></div>
          <div class="hint" id="onlineCount">— online</div>
        </div>
      </div>

      <div class="call-card">
        <div class="small">Device selection</div>
        <div class="device-row" style="margin-top:.35rem">
          <label class="small" for="inputSelect">Mic</label>
          <select id="inputSelect"></select>
        </div>
        <div class="device-row" style="margin-top:.35rem">
          <label class="small" for="outputSelect">Speaker</label>
          <select id="outputSelect"></select>
        </div>

        <div style="height:8px"></div>

        <div class="small">Voice calls (peer-to-peer)</div>

        <div style="display:flex;gap:.5rem">
          <button id="createCallBtn">Create Call</button>
          <button id="hangupBtn" style="display:none">Hang up</button>
        </div>

        <div style="display:flex;gap:.5rem;margin-top:.4rem">
          <input id="callInput" type="text" placeholder="Enter call ID to join" style="flex:1" />
          <button id="joinCallBtn">Join</button>
        </div>

        <div style="display:flex;gap:.5rem;margin-top:.5rem;align-items:center">
          <button id="muteBtn">Mute</button>
          <div class="hint" id="callStatus">Not in call</div>
        </div>

        <div style="margin-top:.6rem">
          <audio id="remoteAudio" autoplay playsinline></audio>
          <div class="hint" style="margin-top:.4rem">NOTE: This demo uses a public STUN server only. For reliable calls behind NATs, add a TURN server (production).</div>
        </div>
      </div>

      <div>
        <div class="small">Debug / Info</div>
        <div class="hint" id="debugBox" style="margin-top:.4rem;white-space:pre-wrap;max-height:220px;overflow:auto"></div>
      </div>
    </div>
  </div>

  <script type="module">
    // Firebase + Firestore libs (modular) via CDN
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import {
      getAuth,
      signInAnonymously,
      onAuthStateChanged,
      signOut
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import {
      getFirestore,
      collection,
      addDoc,
      serverTimestamp,
      query,
      orderBy,
      limit,
      onSnapshot,
      doc,
      setDoc,
      getDoc,
      updateDoc
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

    // ========================
    // CONFIG — keep your project's config
    const firebaseConfig = {
      apiKey: "AIzaSyD2Q2TDCQDVcmmhR7zzVVTMtBkaS40cOx0",
      authDomain: "talk-a-lot-5aad8.firebaseapp.com",
      projectId: "talk-a-lot-5aad8",
      storageBucket: "talk-a-lot-5aad8.firebasestorage.app",
      messagingSenderId: "373420699612",
      appId: "1:373420699612:web:11f4470e6e0097b6576919",
      measurementId: "G-P0VNPFJ2HD"
    };
    // ========================

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // UI refs
    const statusEl = document.getElementById('status');
    const messagesEl = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const anonBtn = document.getElementById('anonSignIn');
    const signOutBtn = document.getElementById('signOut');
    const displayNameInput = document.getElementById('displayName');
    const displayNameLabel = document.getElementById('displayNameLabel');
    const uidLabel = document.getElementById('uidLabel');
    const typingIndicator = document.getElementById('typingIndicator');
    const onlineCount = document.getElementById('onlineCount');
    const debugBox = document.getElementById('debugBox');

    // Device UI
    const inputSelect = document.getElementById('inputSelect');
    const outputSelect = document.getElementById('outputSelect');

    // Call UI
    const createCallBtn = document.getElementById('createCallBtn');
    const joinCallBtn = document.getElementById('joinCallBtn');
    const callInput = document.getElementById('callInput');
    const hangupBtn = document.getElementById('hangupBtn');
    const muteBtn = document.getElementById('muteBtn');
    const callStatus = document.getElementById('callStatus');
    const remoteAudio = document.getElementById('remoteAudio');

    // Local state
    let currentUser = null;
    let displayName = localStorage.getItem('talkalot_displayName') || '';
    displayNameInput.value = displayName;
    displayNameLabel.textContent = displayName || '(anonymous)';

    // Device selection state
    const SAVE_KEYS = { input: 'talkalot_inputDevice', output: 'talkalot_outputDevice' };

    // Chat setup
    const messagesCol = collection(db, 'chat_messages');
    const recentQuery = query(messagesCol, orderBy('createdAt', 'asc'), limit(500));

    // Presence & typing
    const presenceCol = collection(db, 'presence'); // doc per uid
    const TYPING_TIMEOUT = 1500;
    let typingTimer = null;

    // WebRTC state
    let localStream = null;
    let pc = null;
    let callDocRef = null;
    let callerCandidatesCol = null;
    let calleeCandidatesCol = null;
    let localAudioEnabled = true;

    // Helpers
    function logDebug(...args){ debugBox.textContent = (new Date()).toLocaleTimeString() + ' • ' + args.join(' ') + '\n' + debugBox.textContent; }
    function escapeHTML(s){ return String(s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }
    function shortUid(uid){ return uid ? uid.slice(0,6) : '(no-uid)'; }
    function avatarColor(uid){
      const colors = ['#ef4444','#f97316','#f59e0b','#10b981','#06b6d4','#3b82f6','#8b5cf6','#ec4899'];
      if(!uid) return colors[0];
      const n = uid.split('').reduce((a,c)=>a + c.charCodeAt(0),0);
      return colors[n % colors.length];
    }

    // Render a message
    function renderMessage(msg){
      const row = document.createElement('div');
      row.className = 'msg-row ' + ((currentUser && msg.uid === currentUser.uid) ? 'me' : 'other');

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.style.background = avatarColor(msg.uid || msg.displayName || '');
      avatar.textContent = (msg.displayName || shortUid(msg.uid) || '?').slice(0,2).toUpperCase();

      const bubbleWrap = document.createElement('div');
      bubbleWrap.style.display = 'flex';
      bubbleWrap.style.flexDirection = 'column';

      const meta = document.createElement('div');
      meta.className = 'meta';
      const name = escapeHTML(msg.displayName || shortUid(msg.uid));
      const time = msg.createdAt && msg.createdAt.toDate ? msg.createdAt.toDate().toLocaleTimeString() : '';
      meta.innerHTML = `<strong>${name}</strong> <span style="color:var(--muted);margin-left:.45rem">${time}</span>`;

      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      bubble.innerHTML = escapeHTML(msg.text);

      bubbleWrap.appendChild(meta);
      bubbleWrap.appendChild(bubble);

      // order: if me, show bubble then avatar on right
      if(currentUser && msg.uid === currentUser.uid){
        row.appendChild(bubbleWrap);
        row.appendChild(avatar);
      } else {
        row.appendChild(avatar);
        row.appendChild(bubbleWrap);
      }

      return row;
    }

    // Messages listener
    onSnapshot(recentQuery, snapshot => {
      messagesEl.innerHTML = '';
      const docs = [];
      snapshot.forEach(docSnap => docs.push(docSnap.data()));
      for(const d of docs){
        messagesEl.appendChild(renderMessage(d));
      }
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }, err => {
      console.error('Messages listener error', err);
      logDebug('Messages listener error', err.message || err);
    });

    // Send message
    async function sendMessage(){
      const text = messageInput.value.trim();
      if(!text) return;
      if(!currentUser){ statusEl.textContent = 'Sign in to send messages'; return; }
      if(text.length > 1500){ statusEl.textContent = 'Message too long'; return; }
      sendBtn.disabled = true;
      try {
        await addDoc(messagesCol, {
          uid: currentUser.uid,
          displayName: displayName || null,
          text,
          createdAt: serverTimestamp()
        });
        messageInput.value = '';
        statusEl.textContent = 'Sent';
      } catch(err){
        console.error(err);
        statusEl.textContent = 'Send failed: ' + (err.message || err);
      } finally { sendBtn.disabled = false; }
    }
    sendBtn.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', e => {
      if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendMessage(); }
      notifyTyping();
    });
    messageInput.addEventListener('input', notifyTyping);

    // Typing indicator: write typing state to presence doc for this user
    async function setTyping(val){
      if(!currentUser) return;
      try {
        const pDoc = doc(db, 'presence', currentUser.uid);
        await setDoc(pDoc, { uid: currentUser.uid, displayName: displayName || null, typing: val, lastSeen: serverTimestamp() }, { merge: true });
      } catch(e){ console.warn('typing set failed', e); }
    }
    function notifyTyping(){
      if(!currentUser) return;
      setTyping(true);
      clearTimeout(typingTimer);
      typingTimer = setTimeout(()=>setTyping(false), TYPING_TIMEOUT);
    }

    // Presence: watch presence collection to show count and typing
    onSnapshot(collection(db,'presence'), snapshot => {
      let online = 0;
      const typers = [];
      snapshot.forEach(d => {
        const data = d.data();
        if(data) online++;
        if(data.typing && data.uid !== (currentUser && currentUser.uid)) typers.push(data.displayName || shortUid(data.uid));
      });
      onlineCount.textContent = `${online} online`;
      typingIndicator.textContent = typers.length ? `${typers.join(', ')} typing…` : '';
    });

    // Auth handlers
    anonBtn.addEventListener('click', async () => {
      anonBtn.disabled = true;
      try { await signInAnonymously(auth); }
      catch (err){ statusEl.textContent = 'Sign-in error: ' + (err.message || err); console.error(err); }
      finally { anonBtn.disabled = false; }
    });
    signOutBtn.addEventListener('click', async () => {
      signOutBtn.disabled = true;
      try { await signOut(auth); } catch (err){ console.error(err); statusEl.textContent = 'Sign-out error: ' + err.message; }
      finally { signOutBtn.disabled = false; }
    });
    displayNameInput.addEventListener('change', () => {
      displayName = displayNameInput.value.trim().slice(0,40);
      localStorage.setItem('talkalot_displayName', displayName);
      displayNameLabel.textContent = displayName || '(anonymous)';
      if(currentUser) setDoc(doc(db, 'presence', currentUser.uid), { uid: currentUser.uid, displayName, lastSeen: serverTimestamp() }, { merge:true });
    });

    // Update presence on auth state change
    onAuthStateChanged(auth, user => {
      currentUser = user;
      if(user){
        statusEl.textContent = 'Signed in ' + (user.isAnonymous ? '(anonymous)' : '');
        anonBtn.style.display = 'none';
        signOutBtn.style.display = 'inline-block';
        uidLabel.textContent = `uid: ${shortUid(user.uid)}`;
        setDoc(doc(db, 'presence', user.uid), { uid: user.uid, displayName, typing: false, lastSeen: serverTimestamp() }, { merge: true });
        window.addEventListener('beforeunload', () => {
          setDoc(doc(db, 'presence', user.uid), { lastSeen: serverTimestamp(), online:false }, { merge:true });
        });
      } else {
        statusEl.textContent = 'Not signed in';
        anonBtn.style.display = 'inline-block';
        signOutBtn.style.display = 'none';
        uidLabel.textContent = '';
      }
      displayNameLabel.textContent = displayName || (user ? shortUid(user.uid) : '(anonymous)');
    });

    // -----------------------
    // Device selection & management
    // -----------------------
    async function enumerateAndPopulateDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const inputs = devices.filter(d => d.kind === 'audioinput');
        const outputs = devices.filter(d => d.kind === 'audiooutput');

        const savedIn = localStorage.getItem(SAVE_KEYS.input) || '';
        const savedOut = localStorage.getItem(SAVE_KEYS.output) || '';

        // helper to set options
        function fill(selectEl, list, saved, kindLabel) {
          const prev = selectEl.value;
          selectEl.innerHTML = '';
          const noneOpt = document.createElement('option');
          noneOpt.value = '';
          noneOpt.textContent = `Default ${kindLabel}`;
          selectEl.appendChild(noneOpt);
          list.forEach(d=>{
            const option = document.createElement('option');
            option.value = d.deviceId;
            // device labels may be empty until permission granted
            option.textContent = d.label || `${kindLabel} ${selectEl.length}`;
            selectEl.appendChild(option);
          });
          if(saved) selectEl.value = saved;
          else if(prev) selectEl.value = prev;
        }

        fill(inputSelect, inputs, savedIn, 'Mic');
        fill(outputSelect, outputs, savedOut, 'Speaker');

        // if output saved set sink now
        const outId = outputSelect.value;
        if(outId) await applyOutputDevice(outId);
      } catch (e) {
        console.warn('enumerateDevices failed', e);
      }
    }

    // apply chosen output device to remoteAudio
    async function applyOutputDevice(deviceId) {
      if(!remoteAudio) return;
      if(typeof remoteAudio.setSinkId !== 'function') {
        logDebug('setSinkId not supported in this browser');
        return;
      }
      try {
        await remoteAudio.setSinkId(deviceId || '');
        localStorage.setItem(SAVE_KEYS.output, deviceId || '');
        logDebug('Output set to', deviceId || 'default');
      } catch (e) {
        console.warn('setSinkId failed', e);
        logDebug('setSinkId failed: ' + (e.message || e));
      }
    }

    // start or restart local audio with selected device
    async function startLocalAudio() {
      const selectedInput = inputSelect.value || localStorage.getItem(SAVE_KEYS.input) || '';
      // build constraints
      const audioConstraints = selectedInput ? { deviceId: { exact: selectedInput } } : true;
      try {
        const newStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
        // stop previous tracks
        if(localStream) {
          localStream.getTracks().forEach(t => t.stop());
        }
        localStream = newStream;
        // if in a call and pc exists, replace audio track(s)
        if(pc) {
          const senders = pc.getSenders ? pc.getSenders() : [];
          const newTrack = localStream.getAudioTracks()[0];
          for(const sender of senders){
            if(sender.track && sender.track.kind === 'audio') {
              try { await sender.replaceTrack(newTrack); } catch(e){ console.warn('replaceTrack failed', e); }
            }
          }
        }
        // remember selected input
        localStorage.setItem(SAVE_KEYS.input, selectedInput || '');
        logDebug('Local audio started (device)', selectedInput || 'default');
        return localStream;
      } catch (e) {
        console.error('startLocalAudio failed', e);
        logDebug('startLocalAudio failed: ' + (e.message || e));
        throw e;
      }
    }

    // respond to select changes
    inputSelect.addEventListener('change', async () => {
      const id = inputSelect.value || '';
      localStorage.setItem(SAVE_KEYS.input, id);
      // restart local audio (and replace track in active pc if any)
      try { await startLocalAudio(); } catch(e){ console.warn(e); }
    });
    outputSelect.addEventListener('change', async () => {
      const id = outputSelect.value || '';
      localStorage.setItem(SAVE_KEYS.output, id);
      await applyOutputDevice(id);
    });

    // update device lists when devices change (plug/unplug)
    navigator.mediaDevices.addEventListener?.('devicechange', enumerateAndPopulateDevices);

    // initialize devices: try to get permission to get labels if not present
    async function initDevices() {
      try {
        // If labels are empty, prompt for permission briefly to allow proper labels. Only do if necessary.
        const devices = await navigator.mediaDevices.enumerateDevices();
        const needPerm = devices.some(d => (d.kind === 'audioinput') && !d.label);
        if(needPerm) {
          try {
            const tmpStream = await navigator.mediaDevices.getUserMedia({ audio:true });
            tmpStream.getTracks().forEach(t => t.stop());
          } catch (_) {
            // user denied or not available — we'll still list devices, labels may be empty
          }
        }
      } catch (e) {
        console.warn('initDevices enumerate failed', e);
      } finally {
        await enumerateAndPopulateDevices();
      }
    }

    // -----------------------
    // WebRTC voice calling (simple Firestore signaling)
    // -----------------------
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    createCallBtn.addEventListener('click', async () => {
      if(!currentUser){ alert('Sign in first'); return; }
      createCallBtn.disabled = true;
      logDebug('Creating call…');
      try {
        await startLocalAudio();
        pc = new RTCPeerConnection(rtcConfig);

        // add local stream tracks
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        // remote track handling
        pc.ontrack = (event) => {
          logDebug('Remote track received');
          remoteAudio.srcObject = event.streams[0];
        };

        // create call doc reference and subcollections AFTER pc exists
        const callRef = doc(collection(db, 'calls'));
        callDocRef = callRef;
        callerCandidatesCol = collection(callRef, 'callerCandidates');
        calleeCandidatesCol = collection(callRef, 'calleeCandidates');

        // ICE candidates -> save to callerCandidates subcollection
        pc.onicecandidate = (event) => {
          if(event.candidate){
            const c = event.candidate.toJSON();
            if(callerCandidatesCol) addDoc(callerCandidatesCol, c).catch(e=>logDebug('ICE write err',e.message));
          }
        };

        // create and persist offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        await setDoc(callRef, {
          offer: { type: offer.type, sdp: offer.sdp },
          createdBy: currentUser.uid,
          createdAt: serverTimestamp()
        });

        // apply output device if previously selected
        const savedOutput = localStorage.getItem(SAVE_KEYS.output) || outputSelect.value || '';
        if(savedOutput) await applyOutputDevice(savedOutput);

        // listen for answer on call doc
        onSnapshot(callRef, async snap => {
          const data = snap.data();
          if(!pc.currentRemoteDescription && data && data.answer){
            logDebug('Answer received, setting remote description');
            const answer = new RTCSessionDescription(data.answer);
            await pc.setRemoteDescription(answer);
            callStatus.textContent = `In call (id: ${callRef.id})`;
            callInput.value = callRef.id;
            hangupBtn.style.display = 'inline-block';
            createCallBtn.style.display = 'none';
          }
        });

        // listen for callee ICE candidates
        onSnapshot(calleeCandidatesCol, snapshot => {
          snapshot.docChanges().forEach(async change => {
            if(change.type === 'added'){
              const c = change.doc.data();
              try { await pc.addIceCandidate(c); } catch(e){ console.warn('addIceCandidate failed', e); }
            }
          });
        });

        logDebug('Call created with ID', callRef.id);
        callStatus.textContent = `Waiting for answer (id: ${callRef.id})`;
        callInput.value = callRef.id;
      } catch (e){
        console.error(e);
        logDebug('Create call failed', e.message || e);
        alert('Create call failed: ' + (e.message || e));
      } finally {
        createCallBtn.disabled = false;
      }
    });

    joinCallBtn.addEventListener('click', async () => {
      const callId = callInput.value.trim();
      if(!callId){ alert('Enter call ID to join'); return; }
      if(!currentUser){ alert('Sign in first'); return; }
      joinCallBtn.disabled = true;
      logDebug('Joining call', callId);
      try {
        const callRef = doc(db, 'calls', callId);
        const callSnap = await getDoc(callRef);
        if(!callSnap.exists()){
          alert('Call not found');
          joinCallBtn.disabled = false;
          return;
        }
        await startLocalAudio();
        pc = new RTCPeerConnection(rtcConfig);
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        pc.ontrack = (event) => {
          remoteAudio.srcObject = event.streams[0];
        };
        pc.onicecandidate = (event) => {
          if(event.candidate){
            const c = event.candidate.toJSON();
            if(calleeCandidatesCol) addDoc(calleeCandidatesCol, c).catch(e=>logDebug('ICE write err',e.message));
          }
        };

        callerCandidatesCol = collection(callRef, 'callerCandidates');
        calleeCandidatesCol = collection(callRef, 'calleeCandidates');

        // apply remote offer
        const data = callSnap.data();
        if(!data.offer){ throw new Error('Offer not found in call doc'); }
        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await updateDoc(callRef, { answer: { type: answer.type, sdp: answer.sdp } });

        // listen for caller candidates to add
        onSnapshot(callerCandidatesCol, snapshot => {
          snapshot.docChanges().forEach(async change => {
            if(change.type === 'added'){
              const c = change.doc.data();
              try { await pc.addIceCandidate(c); } catch(e){ console.warn('addIceCandidate failed', e); }
            }
          });
        });

        // set output device if saved
        const savedOutput = localStorage.getItem(SAVE_KEYS.output) || outputSelect.value || '';
        if(savedOutput) await applyOutputDevice(savedOutput);

        hangupBtn.style.display = 'inline-block';
        createCallBtn.style.display = 'none';
        callStatus.textContent = `In call (id: ${callId})`;
        logDebug('Joined call', callId);
      } catch (e){
        console.error(e);
        logDebug('Join call failed', e.message || e);
        alert('Join failed: ' + (e.message || e));
      } finally {
        joinCallBtn.disabled = false;
      }
    });

    // Mute/unmute local audio track
    muteBtn.addEventListener('click', () => {
      if(!localStream) return;
      localAudioEnabled = !localAudioEnabled;
      localStream.getAudioTracks().forEach(t => t.enabled = localAudioEnabled);
      muteBtn.textContent = localAudioEnabled ? 'Mute' : 'Unmute';
    });

    // Hang up: close pc and optionally mark call doc ended
    hangupBtn.addEventListener('click', async () => {
      try {
        if(pc){ pc.close(); pc = null; }
        if(localStream){ localStream.getTracks().forEach(t => t.stop()); localStream = null; remoteAudio.srcObject = null; }
        if(callDocRef){
          try { await updateDoc(callDocRef, { endedAt: serverTimestamp() }); } catch(e){}
          callDocRef = null;
        }
        hangupBtn.style.display = 'none';
        createCallBtn.style.display = 'inline-block';
        callStatus.textContent = 'Not in call';
        logDebug('Call ended');
      } catch(e){ console.warn('hangup error', e); }
    });

    // Shortcuts: pressing Enter in callInput joins
    callInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); joinCallBtn.click(); } });

    // initialize device lists & try to get labels
    initDevices().catch(()=>{ /* ignore */ });

    // Apply saved output (if any) on load
    (async () => {
      const savedOutput = localStorage.getItem(SAVE_KEYS.output) || '';
      if(savedOutput) {
        // if setSinkId not supported, log only
        if(typeof remoteAudio.setSinkId === 'function') {
          try { await remoteAudio.setSinkId(savedOutput); } catch(e){ console.warn('setSinkId initial failed', e); }
        }
      }
      logDebug('Client ready — project:', firebaseConfig.projectId);
      messageInput.focus();
    })();

    // End of module
  </script>
</body>
</html>
